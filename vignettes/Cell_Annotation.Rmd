---
title: "Cell Annotation using the Miko Scoring Pipeline"
output:
  html_document:
    theme: united
    df_print: kable
  pdf_document: default
date: 'Compiled: `r Sys.Date()`'
---


```{r setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE
)
```

## Load Seurat object

For this tutorial we will annotate the Human Gastrulation dataset reported by Tyser 2021 using the gene set-based miko scoring workflow.

We start by reading in the data and visualizing the (ground-truth) annotated population. 

```{r load data, fig.width=7, fig.height=5}

# load package
library(scMiko)

# load human gastrulation data
so.query <- readRDS("../data/so_tyser2021_220621.rds")

# visualize annotated populations. 
cluster.UMAP(so = so.query, group.by = "sub_cluster") + 
  theme_void() + 
  labs(title = "Tyser 2021", subtitle = "Human Gastrulation")

```

Prior to running the Miko scoring pipeline, you must ensure that the loaded Seurat object has been clustered using `FindClusters(...)` and that cluster information is available in the 'seurat_clusters' meta data field. 

```{r seurat clusters}

# ensure that seurat_clusters are available
stopifnot("seurat_clusters" %in% colnames(so.query@meta.data))

# visualize seurat clusters
cluster.UMAP(so.query, group.by = "seurat_clusters")
```


## Prepare cell-type markers

Prior to performing marker-based cell-type annotation, we first prepare a comprehensive list of cell-type markers. We will use a cell-type catalog derived from multiple public scRNAseq atlases (see Cell-type marker catalog vignette for details). 

In the absence of a-priori sample information, we would include all the cell-type markers in the catalog. However, given the known early embryonic age of the profiled sample, we will proceed with cell-markers derived from murine organogenesis (Cao 2019), human fetus (Cao 2020), developing murine brain (La Manno 2021), and murine gastrulation (Pijuan-Sala 2019):



```{r cell markers}

# cell-type catalog 
marker.list <- geneSets[["Cell_Catalog"]]

# only include gene sets with more than 3 markers
marker.list <- marker.list[unlist(lapply(marker.list, length)) > 3]

# subset markers
marker.list <- marker.list[grepl("Cao2019|Cao2020|Manno|Pijuan", names(marker.list))]

```


## Miko scoring pipeline

The miko scoring pipeline is a 3-step workflow that is implemented in `nullScore`, `mikoScore`, and `sigScore` functions. In step 1 we run `nullScore`, which fits a null model that corrects for gene set-size biases. 


```{r calculate null model, fig.width=14, fig.height=4.5}

# step 1
ns.res <- nullScore(object = so.query, assay = DefaultAssay(so.query), n.replicate = 10, nbin = 24, 
                    min.gs.size = 2, max.gs.size = 200, step.size = 10, 
                    nworkers = 16, verbose = T, subsample.n = 5000)


```

From this example, the variance-gene set-size relationship can be appreciated in panel `A` and `B`. Panel `C` illustrates the correction that is applied to ensure that the null score variance is constant across all gene set sizes.  

```{r visualize null model,  fig.width=14, fig.height=4.5}

variance.mean.plot <- ns.res$variance.mean.plot
plt.null.model <- ns.res$mean.plot
plt.corrected.plot <- ns.res$corrected.plot

cowplot::plot_grid(variance.mean.plot + labs( subtitle = ""), 
                   plt.null.model, 
                   plt.corrected.plot + labs(title = "Gene Set-Size Corrected Null Scores", subtitle = ""), 
                   nrow = 1, align = "h", labels = "AUTO")
```

In step 2, cell-type marker sets are scored using `mikoScore`. 

```{r cell-level scores,  fig.width=16, fig.height=15}

# step 2
so.query_scored <- mikoScore(object = so.query, geneset = marker.list, nbin = 24, 
                            nullscore = ns.res, assay = DefaultAssay(so.query), nworkers = 18)

```

Finally, in step 3, we identify which cell-type marker sets are significantly enriched in each cluster. 

```{r significantly enriched gene sets}

# step 3
score.result <- sigScore(object = so.query_scored,  geneset = marker.list, reduction = "umap")

# visualize 
score.result$score_plot

```

## Post-scoring filters

We use two additional post-scoring filters to fine tune which gene sets are enriched. The first is a coherence filter in which a positive correlation between component gene expression and the Miko score is enforced for a minimum fraction of component genes. The second is a frequent flier filter, which flags gene sets that exceed a minimum significance rate and represent gene sets that enrich across most cell clusters. 

### Coherence filter

```{r coh filter}

raw.mat <- so.query_scored@misc[["raw_score"]]
colnames(raw.mat) <- gsub("raw_", "", colnames(raw.mat))

df.cscore <- coherentFraction(object = so.query_scored, score.matrix =raw.mat, nworkers = 16,
                              method = "pearson",
                            genelist = marker.list, 
                            assay = DefaultAssay(so.query_scored), 
                            slot = "data", subsample.cluster.n = 500)

df.score <- score.result$cluster_stats
df.score$gs <- df.score$name
df.score$cluster <- df.score$cluster
df.merge <- merge(df.cscore, df.score, by = c("gs", "cluster"))

df.merge$sig <- df.merge$coherence_fraction >= 0.8 & df.merge$miko_score > 0 & df.merge$fdr < 0.05
plt.score.vs.coh <- df.merge %>%
  ggplot(aes(x = (miko_score), y = coherence_fraction, label = gs, fill = sig)) + 
  geom_point(pch = 21, color = "white", size = 2) + 
  theme_miko(legend = T) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  scale_fill_manual(values = c("TRUE" = "tomato", "FALSE" = "grey")) + 
  labs(x = "Miko Score", y = "Coherence Fraction", fill = "Enriched & Coherent\n(FDR<0.05)", 
       title = "Coherent Enrichments", 
       subtitle = paste0(100*signif(sum( df.merge$sig) / nrow(df.merge), 3), "% Significance Rate"))


  plt.score.vs.coh


```


```{r consolidate results}

df.score_summary <- data.frame(cluster = df.merge$cluster, 
                              cell.type = df.merge$gs, 
                              miko_score = signif(df.merge$miko_score, 3) ,
                              p =  signif(df.merge$p),
                              fdr =  signif(df.merge$fdr),
                              coherence_fraction =  signif(df.merge$coherence_fraction)
                              # r_mean =  signif(df.merge$r_mean)
)

```

### Frequent flier filter

```{r flag frequent fliers}


ugrp <- unique(df.score_summary$cluster)
df.score_summary.sig <- df.score_summary %>% dplyr::filter(fdr < 0.05)
df.tally.ff <- as.data.frame(table(df.score_summary.sig$cell.type))
df.tally.ff$Freq2 <- df.tally.ff$Freq/length(ugrp)

ff.thresh <- 0.75
which.ff <- as.character(df.tally.ff$Var1[df.tally.ff$Freq2 >= ff.thresh])
df.score_summary$frequent_flier = (df.score_summary$cell.type  %in% which.ff)

```


We can visualize the frequent flier distribution to verify that an appropriate frequent flier threshold was used. In the current sample, we can see that there are a subset of marker sets that enrich indiscriminately in all clusters. In this case a threshold of 0.75 was appropriate (the threshold usually varies 0.6-0.8). 

```{r}

plt.ff <- df.tally.ff %>%
  ggplot(aes(x = Freq2)) + 
  geom_histogram(binwidth = 0.1) + 
  geom_vline(xintercept = ff.thresh, linetype = "dashed", color = "tomato") + 
  labs(title = "Frequent Flier Distribution", subtitle = paste0(signif(100*sum(df.tally.ff$Freq2 > ff.thresh)/nrow(df.tally.ff), 3), "% enriched genesets are frequent fliers (significant > ", 100*ff.thresh, "% of clusters)"),
       x = "Proportion of significant clusters", y = "Number of gene sets") + 
  theme_miko()
plt.ff

```


```{r cloud helper}

annotationCloud <- function(object, 
                            object.group = "seurat_clusters", 
                            score,
                            score.group,
                            score.cell.type,
                            score.p,
                            score.fdr = NULL,
                            score.coherence.fraction = NULL,
                             score.frequenct.flier = NULL,
                            fdr.correction = T, 
                            p.threshold = 0.05, 
                            coherence.threshold = 0.8, 
                            show.n.terms = 15, 
                            verbose = T){
  
  
  require(ggwordcloud)

  miko_message("Generating annotation wordclouds...", verbose = verbose)
  
    if (is.null(score.coherence.fraction)) coherence.threshold <- 0
  if (is.null(score.frequenct.flier)) score.frequenct.flier <- F
  
  vst.merge.cloud <- data.frame(
    miko_score = score, 
    cluster = score.group, 
    cell.type = score.cell.type,
    p = score.p,
    fdr = score.fdr,
    coherence_fraction = score.coherence.fraction,
    frequent_flier = score.frequenct.flier
  )

  u.cl <- unique(vst.merge.cloud$cluster)
  plt.ww.list <- list()
  
  show.w <- show.n.terms
  
  
  plt.cluster.umap <- highlightUMAP(object = object, group = object.group, 
                                    reduction = "umap", highlight.color = "tomato")
  names(plt.cluster.umap) <- as.character(gsub("group_", "",  names(plt.cluster.umap)))
  
    u.cl <- object@meta.data[[object.group]]
  #
  # # get unique clusters
  if (object.group == "seurat_clusters"){
    u.cl <- unique(as.numeric(as.character((u.cl))))
    u.cl <- u.cl[order(u.cl)]
  } else {
    u.cl <- unique((as.character((u.cl))))
  }
  
  
  
  for (i in 1:length(u.cl)){
    
    vst.merge.subset <- vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]
    vst.merge.subset$coh.score <- vst.merge.subset$coherence_fraction
    vst.merge.subset$coh.score[vst.merge.subset$coh.score < coherence.threshold] <- 0
    
    vst.merge.subset <- vst.merge.subset %>% dplyr::filter(miko_score > 0, 
                                                           coherence_fraction >= coherence.threshold, 
                                                           !frequent_flier) 
    
    if (nrow(vst.merge.subset) >0){
      
      
      n.sig.score <- nrow(vst.merge.subset %>% dplyr::filter(fdr < p.threshold, miko_score > 0))
      n.coh.score <- nrow(vst.merge.subset %>% dplyr::filter(fdr < p.threshold,miko_score > 0, 
                                                             coherence_fraction >= coherence.threshold)) #, coh.score 
      
      if (fdr.correction){
        enrich.label <- paste0(n.sig.score, "/", length(marker.list), " (", signif(n.sig.score/  ulength(vst.merge.cloud$cell.type), 2)*100, "%) gene sets are enriched (FDR < 5e-2*, 1e-5**, 1e-8***)\nand exceed ", 100*coherence.threshold, "% coherence")      
      } else {
        enrich.label <- paste0(n.sig.score, "/", length(marker.list), " (", signif(n.sig.score/  ulength(vst.merge.cloud$cell.type), 2)*100, "%) gene sets are enriched (p < 5e-2*, 1e-5**, 1e-8***)\nand exceed ", 100*coherence.threshold, "% coherence")
      }
      
      
      vst.merge.subset$sig.stringent <- vst.merge.subset$fdr < p.threshold & 
        vst.merge.subset$coherence_fraction > coherence.threshold
      df.f1 <- vst.merge.subset %>% dplyr::filter(sig.stringent) %>% 
        dplyr::filter( miko_score > 0, coherence_fraction >= coherence.threshold) %>% #| (coh.fdr < 0.05)
        dplyr::top_n(show.w, miko_score)
      if (nrow(df.f1) < show.w){
        ndif <- show.w - nrow(df.f1)
        df.f1 <- bind_rows(df.f1, vst.merge.subset %>% 
                             dplyr::filter(!sig.stringent) %>%
                             dplyr::filter(miko_score > 0) %>% #| (coh.fdr < 0.05) #fdr < 0.05, 
                             dplyr::top_n(ndif, miko_score))
      }
      if (nrow(df.f1) == 0) next
      
      df.f1$cell.type <- gsub("_|-", " ", df.f1$cell.type)
      df.f1$cell.type <- stringr::str_wrap(df.f1$cell.type, 40)
      
      maxlim <- max(df.f1$miko_score)
      if (maxlim > 30){
        maxlim <- 30
      }
      
      minlim.coh <-  min(df.f1$coh.score)
      maxlim.coh <- max(df.f1$coh.score)
      
      df.f1$miko_score[(df.f1$miko_score) > maxlim] <- maxlim
      df.f1$coh.score[(df.f1$coh.score) > maxlim.coh] <- maxlim.coh
      
      df.f1$cell.type2 <- df.f1$cell.type
      df.f1$cell.type2[df.f1$fdr < p.threshold] <- paste0( df.f1$cell.type[df.f1$fdr < p.threshold], "*")
      df.f1$cell.type2[df.f1$fdr < 1e-5] <- paste0( df.f1$cell.type[df.f1$fdr < 1e-5], "**")
      df.f1$cell.type2[df.f1$fdr < 1e-8] <- paste0( df.f1$cell.type[df.f1$fdr < 1e-8], "***")
      
      df.f1$cell.type3 <- df.f1$cell.type2
      
      limseq <- unique(round( seq(-log10(p.threshold), maxlim, by = signif((maxlim-(-log10(p.threshold)))/4, 1))))
      
      if (fdr.correction){
        col.label <- "-log10(FDR)"
      } else {
        col.label <- "-log10(p)"
      }
      
      w1 <- df.f1 %>%
        ggplot(aes(label = cell.type3, color = -log10(fdr), size = abs(miko_score))) +
        geom_text_wordcloud(scale_size_area = 40, rm_outside = TRUE, eccentricity = 1, show.legend = T) +
        theme_minimal() +
        labs(title  = "Enriched", subtitle = enrich.label,  size = "Score", color = col.label) + 
        theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) + 
        theme(legend.position = "bottom") + 
        scale_color_gradient2(low = "grey", mid = "grey", high = scales::muted("red"), midpoint = -log10(p.threshold)) + 
        scale_size(range = c(1, 5)) +
        theme( #
          legend.title = element_text(color = "black", size = 10),
          legend.text = element_text(color = "black", size = 8) ,
          legend.box.background = element_rect(colour = "black")
        )
      
      plt.ww.list[[as.character(u.cl[i])]] <- cowplot::plot_grid(plt.cluster.umap[[as.character(u.cl[i])]],w1, ncol = 2) 
      
    } 
  }  
  return(plt.ww.list)
}



```


```{r}

flex.asDT(df.score_summary)
```


```{r, fig.width=8, fig.height=4}

   plt.cloud <- annotationCloud(object = so.query_scored, 
                                object.group = "seurat_clusters", 
                                score = df.score_summary$miko_score,
                                score.group = df.score_summary$cluster,
                                score.cell.type = df.score_summary$cell.type,
                                score.p = df.score_summary$p,
                                score.fdr = df.score_summary$fdr,
                                score.coherence.fraction = df.score_summary$coherence_fraction,
                                score.frequenct.flier = df.score_summary$frequent_flier, # 
                                fdr.correction = T, 
                                p.threshold = 0.05, 
                                coherence.threshold = 0.9, 
                                show.n.terms = 15, 
                                verbose = T)


plt.cloud

```

```{r}

```

