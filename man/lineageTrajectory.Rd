% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utility_functions.R
\name{lineageTrajectory}
\alias{lineageTrajectory}
\title{Get lineage trajectories using principal curves and compute pseudotimes}
\usage{
lineageTrajectory(
  space,
  start = NULL,
  group.labels = NULL,
  thresh = 0.001,
  maxit = 10,
  stretch = 2,
  smoother = "smooth_spline",
  approx_points = 100,
  trace = FALSE,
  plot_iterations = FALSE
)
}
\arguments{
\item{space}{A numeric matrix or a data frame containing the coordinates of samples.}

\item{start}{either a previously fit principal curve, or else a matrix of points that in row order define a starting curve. If missing or NULL, then the first principal component is used. If the smoother is "periodic_lowess", then a circle is used as the start.}

\item{group.labels}{Character vector (same length as number of rows in space) specifying group membership. Optional.}

\item{thresh}{convergence threshold on shortest distances to the curve. Default is 0.001.}

\item{maxit}{maximum number of iterations.}

\item{stretch}{A stretch factor for the endpoints of the curve, allowing the curve to grow to avoid bunching at the end. Must be a numeric value between 0 and 2.}

\item{smoother}{choice of smoother. The default is "smooth_spline", and other choices are "lowess" and "periodic_lowess". The latter allows one to fit closed curves. Beware, you may want to use iter = 0 with lowess().}

\item{approx_points}{Approximate curve after smoothing to reduce computational time. If FALSE, no approximation of the curve occurs. Otherwise, approx_points must be equal to the number of points the curve gets approximated to; preferably about 100.}

\item{trace}{If TRUE, the iteration information is printed}

\item{plot_iteractions}{If TRUE the iterations are plotted.}
}
\value{
list of results containing principal curve fits and coordinates, pseutimes, plots
}
\description{
For given space (e.g., UMAP, PCA, etc.), lineage trajectories are fit using prinicpal curves, and these are then used to derive pseudotimes.
}
\examples{

# get lineage name
lineage.name <- names(ss.lineages)[1]

# get dimnesional reduction for subset of clusters belonging to lineage
dimSubset <- subsetDimRed(so.query, which.features = ss.lineages[[lineage.name]])

# get initial trajectory
start.traj <- inferInitialTrajectory(as.matrix(dimSubset[["reduction"]]), k = length(unique(dimSubset[["features"]])))

# get lineage trajectories
LT.results <- lineageTrajectory(space = as.matrix(dimSubset[["reduction"]]),
              start = start.traj,
              group.labels = dimSubset[["features"]]



}
